Task 1:
     1. Call-by-value method copies the value, so the copy of the variable is being passed to the method.
     So change in the variable changes the copy of it, but not the original data and the original variable.
     Meanwhile, call-by-reference passes the so-called "variable itself" by passing an address of an object.
     Change in the variable affects the value of variable outside the function also.
     Call-by-value is related to the primitive types, values of those are being stored in stack. Call-by-reference
     relates to objects, those are being stored in heap.
     2. The heap is the portion of memory where dynamically allocated memory resides.
     Memory allocated from the heap will remain allocated until the memory is freed or the program terminates.
     3. Undefined behavior (UB) is the result of executing a program whose behavior is prescribed to be unpredictable,
     in the language specification to which the computer code adheres.
     In the following program it is a cast of an int pointer to char ponter. The results are not portable due to endianness issues.
     4. Because we want to preserve incapsulation in our class, so user cannot affect the class data and behaviour in a wrong way.
     5. If this object was not allocated via new. The rest of the code after "delete this" touches any piece of this object.

Task 2:
    1. We return a reference on a newly created object. But, this object was created in stack but not in heap, because
     we never used new or allocated memory for it in any other mean. So this object would be deleted after the function call would be finished.
    2. In order to fix it we can return the copy of the vector.